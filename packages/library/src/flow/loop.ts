import { cloneDeep, isFunction } from 'lodash'
import { Component } from '../base/component'

import { Sequence, SequenceOptions } from './sequence'

const loopDefaults = {
  template: <
    Component | ((parameters: object) => Component) | undefined
  >undefined,
  templateParameters: <Record<string, any>[]>[],
  sample: {
    n: <number | undefined>undefined,
    mode: <'sequential' | 'draw' | 'draw-shuffle' | 'draw-replace'>'sequential',
  },
  shuffleGroups: <string[] | undefined>undefined,
  shuffleUngrouped: false,
}

type LoopOptions = SequenceOptions & typeof loopDefaults

// A loop functions exactly like a sequence,
// except that the components in the loop are
// generated upon initialization from a
// factory function and a data collection.
// Technically, the content is generated by
// mapping the data onto the factory function.
export class Loop extends Sequence {
  constructor(options: Partial<LoopOptions> = {}) {
    super({
      ...cloneDeep(loopDefaults),
      ...options,
    })
  }

  onPrepare() {
    let templateParameters: Record<string, any>[] = []
    if (
      Array.isArray(this.options.templateParameters) &&
      this.options.templateParameters.length > 0
    ) {
      // Shuffle columns independently, if requested
      const shuffleTable =
        Array.isArray(this.options.shuffleGroups) &&
        this.options.shuffleGroups.length

      const shuffledParameters = shuffleTable
        ? this.random.shuffleTable(
            this.options.templateParameters,
            this.options.shuffleGroups,
            this.options.shuffleUngrouped,
          )
        : this.options.templateParameters

      // Sample parameters
      templateParameters = this.random.sampleMode(
        shuffledParameters,
        this.options.sample.n,
        this.options.sample.replace === true
          ? 'draw-replace' // Fallback for deprecated syntax
          : this.options.sample.mode, // Future syntax
      )
    } else {
      console.warn(
        'Empty or invalid parameter set for loop, no content generated',
      )
    }

    // Generate the content by cloning the template,
    // replacing the parameters each time, or by
    // mapping the parameters onto a function that
    // returns a component.
    if (this.options.template instanceof Component) {
      this.options.content = templateParameters.map(p => {
        const c = this.options.template.clone()
        // Extend parameters
        c.options.parameters = {
          ...c.options.parameters,
          ...p,
        }
        return c
      })
    } else if (isFunction(this.options.template)) {
      this.options.content = templateParameters.map((p, i) =>
        this.options.template(p, i, this),
      )
    } else {
      console.warn('Missing or invalid template in loop, no content generated')
    }

    return super.onPrepare()
  }
}

Loop.metadata = {
  module: ['flow'],
  nestedComponents: ['template'],
  parsableOptions: {
    templateParameters: {
      type: 'array',
      content: {
        // Parse the values of objects in
        // the templateParameters array
        content: {
          '*': {},
        },
      },
    },
    sample: {
      type: 'object',
      content: {
        n: { type: 'number' },
        replace: { type: 'boolean' },
        mode: {},
      },
    },
  },
}
