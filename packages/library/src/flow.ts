// Flow control components for lab.js
// @ts-expect-error ts-migrate(7016) FIXME: Try `npm install @types/lodash` if it exists or ad... Remove this comment to see the full error message
import { mean, isFunction } from 'lodash'
import { Component, status } from './core'

// Helper function to handle nested components
export const prepareNested = function(nested: any, parent: any) {
  // Setup parent links on nested components
  nested.forEach((c: any) => c.parent = parent)

  // Set ids on nested components
  nested.forEach((c: any, i: any) => {
    // For each child, use this component's id
    // and append a counter
    if (parent.options.id == null) {
      c.options.id = String(i)
    } else {
      c.options.id = [parent.options.id, i].join('_')
    }
  })

  // Trigger prepare on all nested components
  // @ts-expect-error ts-migrate(2585) FIXME: 'Promise' only refers to a type, but is being used... Remove this comment to see the full error message
  return Promise.all(
    nested.map((c: any) => c.prepare(false)), // indicate automated call
  );
};

// Sequence -----------------------------------------------

// A sequence combines an array of other
// components and runs them sequentially
export class Sequence extends Component {
  static metadata = {
    module: ['flow'],
    nestedComponents: ['content'],
    parsableOptions: {
      shuffle: { type: 'boolean' },
    },
  };

  constructor(options = {}) {
    super({
      // Define an array of nested components
      // to iterate over
      content: [],
      // Shuffle items, if so desired
      shuffle: false,
      ...options,
    })

    // Set default values for current component and index
    this.internals.currentComponent = null
    this.internals.currentPosition = null
  }

  // @ts-expect-error ts-migrate(2705) FIXME: An async function or method in ES5/ES3 requires th... Remove this comment to see the full error message
  async onPrepare() {
    // Shuffle content, if requested
    if (this.options.shuffle) {
      this.options.content = this.random.shuffle(this.options.content)
    }

    // Define an iterator over the content
    this.internals.iterator = this.options.content.entries()
    this.internals.stepper = this.step.bind(this)

    // Prepare nested items
    await prepareNested(this.options.content, this)
  }

  async onRun(frameTimeStamp: any, frameSynced: any) {
    // Make the first step
    return this.step(frameTimeStamp, frameSynced)
  }

  onEnd() {
    // End prematurely, if necessary
    // (check whether there is an active component,
    // and if so, whether it has finished)
    if (this.internals.currentComponent &&
      this.internals.currentComponent.status !== status.done) {
      this.internals.currentComponent.off('after:end', this.internals.stepper)
      this.internals.currentComponent.end('abort by sequence')
    }
  }

  async step(frameTimeStamp: any, frameSynced: any) {
    if (this.status === status.done) {
      throw new Error('Sequence ended, can\'t take any more steps');
    }

    // Move through the content
    const next = this.internals.iterator.next();
    if (next.done) {
      // @ts-expect-error ts-migrate(2345) FIXME: Argument of type '"completion"' is not assignable ... Remove this comment to see the full error message
      return this.end('completion', frameTimeStamp, frameSynced);
    } 
    [this.internals.currentPosition, this.internals.currentComponent] =
        next.value;
    this.internals.currentComponent.on('after:end', this.internals.stepper);
    return this.internals.currentComponent.run(frameTimeStamp, frameSynced);
    
  }

  get progress() {
    // If the sequence has ended,
    // report it as completed
    // (even if content was skipped)
    return this.status === status.done ? 1 : mean(
      this.options.content.map((c: any) => c.progress),
    );
  }
}

// Loop ---------------------------------------------------

// A loop functions exactly like a sequence,
// except that the components in the loop are
// generated upon initialization from a
// factory function and a data collection.
// Technically, the content is generated by
// mapping the data onto the factory function.
// @ts-expect-error ts-migrate(2417) FIXME: Property 'shuffle' is missing in type '{ templateP... Remove this comment to see the full error message
export class Loop extends Sequence {
  static metadata = {
    module: ['flow'],
    nestedComponents: ['template'],
    parsableOptions: {
      templateParameters: {
        type: 'array',
        content: {
          // Parse the values of objects in
          // the templateParameters array
          content: {
            '*': {},
          },
        },
      },
      sample: {
        type: 'object',
        content: {
          n: { type: 'number' },
          replace: { type: 'boolean' },
          mode: {},
        },
      },
    },
  };

  constructor(options = {}) {
    super({
      template: null,
      templateParameters: [],
      sample: {
        n: undefined,
        mode: 'sequential',
      },
      shuffleGroups: undefined,
      shuffleUngrouped: false,
      ...options,
    })
  }

  onPrepare() {
    let templateParameters = []
    if (
      Array.isArray(this.options.templateParameters) &&
      this.options.templateParameters.length > 0
    ) {
      // Shuffle columns independently, if requested
      const shuffleTable =
        Array.isArray(this.options.shuffleGroups) &&
        this.options.shuffleGroups.length

      const shuffledParameters = shuffleTable
        ? this.random.shuffleTable(
          this.options.templateParameters,
          this.options.shuffleGroups,
          this.options.shuffleUngrouped,
        )
        : this.options.templateParameters

      // Sample parameters
      templateParameters = this.random.sampleMode(
        shuffledParameters,
        this.options.sample.n,
        this.options.sample.replace === true
          ? 'draw-replace' // Fallback for deprecated syntax
          : this.options.sample.mode, // Future syntax
      )
    } else {
      console.warn('Empty or invalid parameter set for loop, no content generated')
    }

    // Generate the content by cloning the template,
    // replacing the parameters each time, or by
    // mapping the parameters onto a function that
    // returns a component.
    if (this.options.template instanceof Component) {
      this.options.content = templateParameters.map((p: any) => {
        const c = this.options.template.clone()
        // Extend parameters
        c.options.parameters = {
          ...c.options.parameters,
          ...p,
        }
        return c
      });
    } else if (isFunction(this.options.template)) {
      this.options.content = templateParameters.map(
        (p: any, i: any) => this.options.template(p, i, this),
      )
    } else {
      console.warn('Missing or invalid template in loop, no content generated')
    }

    return super.onPrepare()
  }
}

// Parallel -----------------------------------------------

// A parallel component executes multiple
// other components simultaneously
export class Parallel extends Component {
  static metadata = {
    module: ['flow'],
    nestedComponents: ['content'],
    parsableOptions: {
      mode: {},
    },
  };

  constructor(options = {}) {
    super({
      // The content, in this case,
      // consists of an array of components
      // that are run in parallel.
      content: [],
      mode: 'race',
      ...options,
    })
  }

  async onPrepare() {
    await prepareNested(this.options.content, this)
  }

  // The run method is overwritten at this point,
  // because the original promise is swapped for a
  // version that runs all nested items in parallel
  onRun(frameTimeStamp: any) {
    // End this component when all nested components,
    // or a single component, have ended
    // @ts-expect-error ts-migrate(2585) FIXME: 'Promise' only refers to a type, but is being used... Remove this comment to see the full error message
    Promise[this.options.mode](
      this.options.content.map((c: any) => c.waitFor('end')),
    ).then(() => this.end())

    // Run all nested components simultaneously
    // @ts-expect-error ts-migrate(2585) FIXME: 'Promise' only refers to a type, but is being used... Remove this comment to see the full error message
    return Promise.all(
      this.options.content.map((c: any) => c.run(frameTimeStamp)),
    );
  }

  onEnd() {
    // Cancel remaining running nested components
    this.options.content.forEach((c: any) => {
      if (c.status < status.done) {
        c.end('abort by parallel')
      }
    })
  }

  get progress() {
    // If the parallel has ended,
    // report it as completed
    // (even if content was skipped)
    return this.status === status.done ? 1 : mean(
      this.options.content.map((c: any) => c.progress),
    );
  }
}
