// Flow control components for lab.js
import { mean, isFunction } from 'lodash'
import { Component, status } from './core'
import { LoopOptions, SequenceOptions, ParallelOptions } from './types'

// Helper function to handle nested components
export const prepareNested = function (nested: any, parent: any) {
  // Setup parent links on nested components
  nested.forEach((c: any) => {
    c.parent = parent
  })

  // Set ids on nested components
  nested.forEach((c: any, i: any) => {
    // For each child, use this component's id
    // and append a counter
    if (parent.options.id == null) {
      c.options.id = String(i)
    } else {
      c.options.id = [parent.options.id, i].join('_')
    }
  })

  // Trigger prepare on all nested components
  return Promise.all(
    nested.map((c: any) => c.prepare(false)), // indicate automated call
  )
}

// Sequence -----------------------------------------------

// A sequence combines an array of other
// components and runs them sequentially
export class Sequence extends Component {
  options: SequenceOptions

  static metadata = {
    module: ['flow'],
    nestedComponents: ['content'],
    parsableOptions: {
      shuffle: { type: 'boolean' },
    },
  }

  constructor(options: SequenceOptions = {}) {
    super({
      // Define an array of nested components
      // to iterate over
      content: [],
      // Shuffle items, if so desired
      shuffle: false,
      // Optionally add a counter
      indexParameter: undefined,
      ...options,
    })

    // Set default values for current component and index
    this.internals.currentComponent = null
    this.internals.currentPosition = null
  }

  async onPrepare() {
    // Shuffle content, if requested
    if (this.options.shuffle) {
      this.options.content = this.random.shuffle(this.options.content)
    }

    if (this.options.indexParameter) {
      this.options.content.forEach((c, i) => {
        c.options.parameters[this.options.indexParameter] = i
      })
    }

    // Define an iterator over the content
    this.internals.iterator = this.options.content.entries()
    this.internals.stepper = this.step.bind(this)

    // Prepare nested items
    await prepareNested(this.options.content, this)
  }

  async onRun(frameTimeStamp: any, frameSynced: any) {
    // Make the first step
    return this.step(frameTimeStamp, frameSynced)
  }

  onEnd() {
    // End prematurely, if necessary
    // (check whether there is an active component,
    // and if so, whether it has finished)
    if (
      this.internals.currentComponent &&
      this.internals.currentComponent.status !== status.done
    ) {
      this.internals.currentComponent.off('after:end', this.internals.stepper)
      this.internals.currentComponent.end('abort by sequence')
    }
  }

  async step(frameTimeStamp: any, frameSynced: any) {
    if (this.status === status.done) {
      throw new Error("Sequence ended, can't take any more steps")
    }

    // Move through the content
    const next = this.internals.iterator.next()
    if (next.done) {
      return this.end('completion', frameTimeStamp, frameSynced)
    }
    ;[
      this.internals.currentPosition,
      this.internals.currentComponent,
    ] = next.value
    this.internals.currentComponent.on('after:end', this.internals.stepper)
    return this.internals.currentComponent.run(frameTimeStamp, frameSynced)
  }

  get progress() {
    // If the sequence has ended,
    // report it as completed
    // (even if content was skipped)
    return this.status === status.done
      ? 1
      : mean(this.options.content.map((c: any) => c.progress))
  }
}

// Loop ---------------------------------------------------

// A loop functions exactly like a sequence,
// except that the components in the loop are
// generated upon initialization from a
// factory function and a data collection.
// Technically, the content is generated by
// mapping the data onto the factory function.
export class Loop extends Sequence {
  options: LoopOptions

  static metadata = {
    module: ['flow'],
    nestedComponents: ['template'],
    parsableOptions: {
      templateParameters: {
        type: 'array',
        content: {
          // Parse the values of objects in
          // the templateParameters array
          content: {
            '*': {},
          },
        },
      },
      sample: {
        type: 'object',
        content: {
          n: { type: 'number' },
          replace: { type: 'boolean' },
          mode: {},
        },
      },
      // TODO: Is this really an option?
      // If not, reconsider how metadata is inherited
      shuffle: { type: 'boolean' },
    },
  }

  constructor(options: LoopOptions = {}) {
    super({
      template: null,
      templateParameters: [],
      sample: {
        n: undefined,
        mode: 'sequential',
      },
      shuffleGroups: undefined,
      shuffleUngrouped: false,
      ...options,
    })
  }

  onPrepare() {
    let templateParameters = []
    if (
      Array.isArray(this.options.templateParameters) &&
      this.options.templateParameters.length > 0
    ) {
      // Shuffle columns independently, if requested
      const shuffleTable =
        Array.isArray(this.options.shuffleGroups) &&
        this.options.shuffleGroups.length

      const shuffledParameters = shuffleTable
        ? this.random.shuffleTable(
            this.options.templateParameters,
            this.options.shuffleGroups,
            this.options.shuffleUngrouped,
          )
        : this.options.templateParameters

      // Sample parameters
      templateParameters = this.random.sampleMode(
        shuffledParameters,
        this.options.sample.n,
        this.options.sample.replace === true
          ? 'draw-replace' // Fallback for deprecated syntax
          : this.options.sample.mode, // Future syntax
      )
    } else {
      console.warn(
        'Empty or invalid parameter set for loop, no content generated',
      )
    }

    // Generate the content by cloning the template,
    // replacing the parameters each time, or by
    // mapping the parameters onto a function that
    // returns a component.
    const { template } = this.options
    if (template instanceof Component) {
      this.options.content = templateParameters.map((p: any) => {
        const c = template.clone()
        // Extend parameters
        c.options.parameters = {
          ...c.options.parameters,
          ...p,
        }
        return c
      })
    } else if (isFunction(template)) {
      this.options.content = templateParameters.map((p: any, i: any) =>
        template(p, i, this),
      )
    } else {
      console.warn('Missing or invalid template in loop, no content generated')
    }

    return super.onPrepare()
  }
}

// Parallel -----------------------------------------------

// A parallel component executes multiple
// other components simultaneously
export class Parallel extends Component {
  options: ParallelOptions

  static metadata = {
    module: ['flow'],
    nestedComponents: ['content'],
    parsableOptions: {
      mode: {},
    },
  }

  constructor(options: ParallelOptions) {
    super({
      // The content, in this case,
      // consists of an array of components
      // that are run in parallel.
      content: [],
      mode: 'race',
      ...options,
    })
  }

  async onPrepare() {
    await prepareNested(this.options.content, this)
  }

  // The run method is overwritten at this point,
  // because the original promise is swapped for a
  // version that runs all nested items in parallel
  onRun(frameTimeStamp: any) {
    const { mode } = this.options
    if (!mode) {
      return
    }

    if (mode === 'all') {
      // End this component when all nested components have ended
      Promise.all(
        this.options.content.map((c: any) => c.waitFor('end')),
      ).then(() => this.end())
    }

    if (mode === 'race') {
      // or a single component, have ended
      Promise.race(
        this.options.content.map((c: any) => c.waitFor('end')),
      ).then(() => this.end())
    }

    // Run all nested components simultaneously

    return Promise.all(
      this.options.content.map((c: any) => c.run(frameTimeStamp)),
    )
  }

  onEnd() {
    // Cancel remaining running nested components
    this.options.content.forEach((c: any) => {
      if (c.status < status.done) {
        c.end('abort by parallel')
      }
    })
  }

  get progress() {
    // If the parallel has ended,
    // report it as completed
    // (even if content was skipped)
    return this.status === status.done
      ? 1
      : mean(this.options.content.map((c: any) => c.progress))
  }
}
